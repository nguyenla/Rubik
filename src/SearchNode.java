import java.util.ArrayList;
import java.util.Collection;
import java.util.Stack;

/**
 * An SearchNode object represents a node in a search tree. SearchNode is an
 * abstract class because it does not specify how to compute the cost of a node.
 * Classes derived from SearchNode must do at least two things: (i) compute the
 * cost of the node in all constructors; (ii) implement the createChild method.
 * 
 * @author John MacCormick, Dickinson College
 * @version September 2014
 */
public abstract class SearchNode implements Comparable<SearchNode> {
	// The cost of this node. It is initialized to NaN so that we can check
	// whether derived classes have correctly initialized the cost field in
	// their constructors.
	protected double cost = Double.NaN;

	// The parent of this node in the search tree, or null if this node is the
	// root of the tree.
	protected SearchNode parent;

	// The state of the world that this node represents.
	protected WorldState state;

	// The action that was used to transition from the parent node to this node,
	// or null if this node is the root of the tree.
	protected Action action;

	/**
	 * Creates a new node with the given parent, state, and action.
	 * 
	 * @param parent
	 *            The parent of this node in the search tree, or null if this
	 *            node is the root of the tree.
	 * @param state
	 *            The state of the world that this node represents.
	 * @param action
	 *            The action that was used to transition from the parent node to
	 *            this node, or null if this node is the root of the tree.
	 */
	public SearchNode(SearchNode parent, WorldState state, Action action) {
		this.parent = parent;
		this.state = state;
		this.action = action;
	}

	/**
	 * Returns the cost of this node, or throws a runtime exception if the cost
	 * was not initialized correctly in the constructor when the node was
	 * created.
	 * 
	 * @return The cost of this node.
	 */
	public double getCost() {
		if (Double.isNaN(cost)) {
			throw new RuntimeException(
					"error: cost should have been computed in constructor of "
							+ this.getClass() + "class");
		}
		return cost;
	}

	/**
	 * Returns the parent of this node.
	 * 
	 * @return The parent of this node.
	 */
	public SearchNode getParent() {
		return parent;
	}

	/**
	 * Returns the state of the world represented by this node.
	 * 
	 * @return The state of the world represented by this node.
	 */
	public WorldState getState() {
		return state;
	}

	/**
	 * We want to be able to use SearchNode objects as the elements of a
	 * PriorityQueue, so we must override the compareTo method, specifying that
	 * lower-cost nodes are "less" than higher-cost nodes.
	 * 
	 * @see java.lang.Comparable#compareTo(java.lang.Object)
	 */
	@Override
	public int compareTo(SearchNode other) {
		return ((Double) getCost()).compareTo(other.getCost());
	}

	/**
	 * Prints out a human-readable description of this node.
	 */
	public void print() {
		System.out.println(this.toString());
	}

	/**
	 * Expands this node, returning a collection of all nodes generated by
	 * applying valid actions to the current node.
	 * 
	 * @return A collection of nodes that can be reached by applying actions to
	 *         the current node.
	 */
	public Collection<SearchNode> expand() {
		Collection<Action> actions = state.getValidActions();
		ArrayList<SearchNode> children = new ArrayList<SearchNode>();
		for (Action action : actions) {
			WorldState childState = state.apply(action);
			SearchNode childNode = createChild(childState, action);
			children.add(childNode);
		}
		return children;
	}

	// Create a new node, which is a child of the calling node, and which has
	// the given state and action.
	//
	// Returns: The newly-constructed child node.
	// Param childState: The state to be assigned to the new child node.
	// Param action: The action to be assigned to the new child node.
	protected abstract SearchNode createChild(WorldState childState,
			Action action);

	// return a string describing all of the states and actions on the path
	// from the initial node to the calling node

	/**
	 * Returns a string describing the path from the initial node to the calling
	 * node.
	 * 
	 * @return A string describing all of the states and actions on the path
	 *         from the initial node to the calling node.
	 */
	public String pathDetails() {
		// Step 1: walk up the tree from the current node to the initial
		// node, storing each node encountered on a stack so that the path
		// will be easy to reverse later.
		Stack<SearchNode> path = new Stack<SearchNode>();
		SearchNode current = this;
		path.push(current);
		while (current.parent != null) {
			current = current.parent;
			path.push(current);
		}
		// Step 2: the top of the stack is the initial node, so by popping
		// nodes off the stack one by one, and appending their details to a
		// string, we can build up a complete description of the path from
		// the initial node to the calling node.
		StringBuilder details = new StringBuilder();
		while (!path.empty()) {
			current = path.pop();
			// unless we are at the initial node, the action should be
			// non-null and we should append its details to the string
			if (current.action != null) {
				details.append(current.action.toString() + '\n');
			}
			// append details of this state to the string also
			details.append(current.state.toString() + '\n');
		}
		return details.toString();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		// We choose to only describe the state here, since more details can be
		// obtained from the pathDetails() method if necessary.
		return state.toString();
	}

}
